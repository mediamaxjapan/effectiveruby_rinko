# 第1章 Rubyに体を慣らす

## 項目1 Rubyは何を真と考えているかを正確に理解しよう
* Rubyでは、falseとnilを除くすべての値が真

### TrueClassとFalseClass
trueとfalseはキーワードではなく、実態はTrueClassとFalseClassのオブジェクト。オブジェクトなのでメソッド呼び出しもできる。
TrueClassとFalseClassは新しくオブジェクトを作れないため、trueとfalseが唯一のオブジェクトになる。
trueオブジェクトとfalseオブジェクトを参照する、TRUE定数とFALSE定数も定義されている。

### falseとnilの区別
falseとnilを区別する必要がある場合(nilはデフォルト値とするなど)、下記の方法が使える。
* nil?メソッドを呼ぶ(レシーバがnilならtrueを返す)
* falseをレシーバにして==を呼び出す(FalseClass#==は引数もfalseオブジェクトでなければtrueを返さない)

## 項目2 オブジェクトを扱うときはnilかもしれないということを忘れないようにしよう
### ダックタイピング
引数で渡ってきたオブジェクトに対して、いちいちrespond_to?するようなことはまずない。メソッドがなければ、RubyがNoMethodError例外を生成するに任せている。

テストが非常に重視される理由の一つがこれである。まちがったオブジェクトを渡してしまう類のミスは、優れたテストを使ってえぐり出さなければならない。

しかし、十分にテストされていても、nilが紛れ込んでNoMethodError例外が発生することがある。実行中のプログラムに予想外の形でnilが入り込むルートはおどろくほどたくさんある。最良の防御策は、オブジェクトが実際にはnilオブジェクトかもしれないという前提でコードを書くこと。

### 対策方法
#### いつもnilかもしれないという前提でかく
```
person.save if person
person.save if !person.nil?
person.save unless person.nil?
```
#### 目的の型に変換してしまう
to_sやto_iを用いて変換してしまう。
```
irb(main):004:0> [3,1,4,nil].sort_by{|x| x}
ArgumentError: comparison of Fixnum with nil failed
	from (irb):4:in `sort_by'
	from (irb):4
irb(main):005:0> [3,1,4,nil].sort_by{|x| x.to_i}
=> [nil, 1, 3, 4]
```

#### nilが混ざっているかもしれない変数の集合を扱う場合Array#compactを使う
```
irb(main):006:0> first = 'taro'
=> "taro"
irb(main):007:0> last = 'suzuki'
=> "suzuki"
irb(main):008:0> middle = nil
=> nil
irb(main):009:0> [first, middle, last].compact.join(" ")
=> "taro suzuki"
```

## 項目3 Rubyの暗号めいたPerl風機能を避けよう
### String#=~ではなく、String#matchを使う。
```
def extract_error (message)
  if message =~ /^ERROR:\s+(.+)$/
    $1
  else
    "no error"
  end
end
```
のようなコードではなく、
```
def extract_error (message)
  if m = message.match(/^ERROR:\s+(.+)$/)
    m[1]
  else
    "no error"
  end
end
```
のようにする。前者のコードは$1のような複数の特殊グローバル変数を使うことになるが、後者のコードであればMatchDataオブジェクトに全てのマッチ情報が入る。

また、$1はグローバル変数のように見えて、グローバル変数と異なる挙動をする。下記のコードの通り、メソッドコール時点の$1はnilに置き換えられるし、コールしたメソッドで$1が書き換えられても、呼び出し元の$1に影響しない。
```
def method_a
  $1 #=> nil
  'a' =~ /(a)/
  $1 #=> "a"
end

def method_b
  'b' =~ /(b)/
  $1 #=> "b"
  method_a
  $1 #=> "b"
end
```

### $:のようなグローバル変数は使わない
$:は$LOAD_PATHというわかりやすい別名の変数がある。他の$;や$/についても別名の変数が存在している。ただし、$LOAD_PATH以外についてはEnglishライブラリをロードしなければ使えない。
```
require('English')
```

### $_グローバル変数を読み書きするコードは書かない
```
while readline
  print if ~ /^ERROR:/
end
```
上記のようなコードは書かない。書くとしても、ワンライナーかコードゴルフのときだけにする。

## 項目4 定数がミュータブルなことに注意しよう
### クラス名やモジュール名も定数
Rubyにおいて定数とは、戦闘が大文字になっている識別子のこと。なので、StringやArrayのようなクラスやモジュールの名前は実際には定数。

### 定数はミュータブル
```
NAMES=['suzuki', 'sato']
NAMES << 'saito'
```
のようなコードでもRubyは警告さえ出さない。

このことについてよく考えると、クラスやモジュールの名前は定数であり、クラスはいつでも書き換えられるので(オープンクラス)、定数が参照するオブジェクトはミュータブルにする必要がある。

### 定数を本当にイミュータブルにしたい場合はfreezeメソッドを使う
freezeを呼び出されたレシーバに対して、変更を加えようとするとRuntimeErrorが発生するようになる。
```
[3] pry(main)> NAMES=['suzuki', 'sato'].freeze
=> ["suzuki", "sato"]
[4] pry(main)> NAMES << 'saito'
RuntimeError: can't modify frozen Array
from (pry):4:in `__pry__'
```

一般的な目安として、定数は書き換えを防ぐためにかならずフリーズするようにしよう。

しかし、これでは不十分で、要素オブジェクトは書き換えることができてしまう。
```
[9] pry(main)> NAMES[0] << ' taro'
=> "suzuki taro"
[10] pry(main)> NAMES
=> ["suzuki taro", "sato"]
```

このように配列やハッシュなどのコレクションオブジェクトを参照する定数の場合は、コレクションと要素をフリーズする。
```
[1] pry(main)> NAMES=['suzuki', 'sato'].map!(&:freeze).freeze
=> ["suzuki", "sato"]
[2] pry(main)> NAMES[0] << ' taro'
RuntimeError: can't modify frozen String
```

### 定数に再代入しても文法違反にならない
```
[1] pry(main)> TIMEOUT=5
=> 5
[2] pry(main)> TIMEOUT+=5
(pry):2: warning: already initialized constant TIMEOUT
(pry):1: warning: previous definition of TIMEOUT was here
=> 10
```
このように、警告はでてもエラーにはならない。

しかし、意図せずに定数を再定義したときにRubyに例外を生成させるようにコードを書くことはできる。定数が定義されているクラスやモジュールをフリーズすればよい。

```
module Defaults
  TIMEOUT = 5
end

Defaults.freeze
```

### 定数を定義するときに検討すべきフリーズのレベル
* 定数が参照するオブジェクトをフリーズする
* 定数が定義されているモジュールをフリーズする
* 定数が参照するオブジェクトがさらに参照するオブジェクトもフリーズする(オブジェクトを深くフリーズする)

## 項目5 実行時の警告に注意しよう
Rubyがコンパイル時と実行時の2フェーズでコードを操作すると考えると何かと役に立つ。コードの構文を解析して意味を解釈するのはコンパイル時であり、意味を理解したコードを実行するのは実行時である。コンパイル時に生成される警告は、通常、Rubyが回避できた構文上の問題に関係がある。実行時の警告は、バグの原因になっているかもしれないプログラミングのまずさを示している。

### コンパイル時に生成される警告
コンパイル時に生成される警告の大多数は、Rubyが曖昧な構文を検出し、さまざまな解釈のなかから1つを選んで先に進んだときに生成される。Rubyがコードの意図を推測するようなことは明らかに避けたいこと。

```
irb(main):001:0>  '808'.split /0/
(irb):1: warning: ambiguous first argument; put parentheses or even spaces
=> ["8", "8"]
```
Rubyパーサーは、最初のスラッシュに達したときに、正規表現リテラルの先頭なのか、除算演算子なのかを判断しなければならない。これはかっこを使うだけで避けることができる。
```
irb(main):002:0>  '808'.split(/0/)
=> ["8", "8"]
```

コンパイル時警告では、変数関係のものも役に立つ。たとえば、値を代入しただけで、使われていない変数があればRubyは警告を出力する。これは、メモリをわずかに浪費していることの他に、計算に入れなければならない値を忘れている可能性を示している。

かならずしも何かまずいことをしているという意味ではないが、そういう意味になることも確実にある。だから、警告された箇所をよくチェックし、それにしたがってソースコードを書き換えること。

### 実行時に生成される警告
初期化されていないインスタンス変数にアクセスしたり、既存のメソッドを再定義したりといった疑わしいことをコードを行ってからでなければ生成されない警告。

コンパイル時に生成される警告と同様に、警告された箇所を確認して対応しよう。

### 警告をだす方法
#### rubyのオプション
rubyのオプションに-wを指定する。
```
ruby -w script.rb
```

#### RUBYOPT環境変数
RUBYOPT環境変数に"-w"を設定しておく。ウェブサーバが自動的に起動するプログラムや、Rakeなどを使ってテストをするときに使える。

#### $VERBOSEグローバル変数
コードの中で$VERBOSEグローバル変数(別名$-w)にtrueをセットする(falseだと警告量が減り、nilだと無効化される)。

ただし、この方法では、コンパイル時警告は表示されない。なぜなら、プログラム実行前にコンパイルが行われ、プログラムが実行されるまで$VERBOSE変数に値が設定されないからだ。

#### ガイドライン
コンパイル時警告を有効にするために、-wオプションを使うかRUBYOPTに"-w"を設定する。実行時警告は$VERBOSEグローバル変数で制御する。

著者の考えでは、開発中およびテスト中は、コンパイル時警告も実行時警告も有効にしたほうがよい。どうしても実行時警告を無効にしたければ、$VERBOSEグローバル変数にnilをセットすればよい。
