# 36   MiniTestユニツトテストに慣れよう
MiniTestは使いやすく新しさを感じさせるフレームワーク。
1.9以降露 Rubyとともに配布されており、バージョンが上がるたびによくなっている。
インストールしなければならないものはない。
ファイルがあってテストケースを書けばよい。

MiniTestで本当によいと思う機能の1つは、
『TestUnitインターフェイスをエミュレートするSbim (互換機能)が含まれていること。
そのため、新しいバージョンのRubyで動作するように古いコードを書き換えるときに、
既存のTestUnitテストをそのまま残しておけば引き続き使える。

* MiniTest使用時の決まり。
  * テストファイルは使う可能性のあるフレームワークに適した命名規則を(例えばRailsでは”_test”)
  * 最初にライブラリ全体をロードする。(require(‘minitest/autorun’)
  * テストケースを表すクラスを定義する。通常はファイル名に合わせる。(versioクラスのテストなら、version_test.rb)
  * 個々のテストはインスタンスメソッドとして書き、名前の先頭には”test_”というプレフィックスを付ける。
  * テストメソッドは出来る限り小さくする。(実行時にメソッドをランダムに並べるから、テストの順序依存に光を当てることができるため)

下記の例はVsrsionクラスが文字列から正しいメジャーバージョン番号を読み取れているかの単純なテスト。
```
def test_major_number  v = Version.new("2.1.3")  assert(v.major == 2, "major should be 2”)end
```

上記のメソッドではアサーションを使って実際に何かをテストする方法をよく示している。
アサーションメソッドには様々なものがあるが、最も簡単なのはassertメソッド。
このメソッドは必須引数として、trueでなければならない値を取る。
引数がtrueなら合格し、通常の政府ょフローを実行し続けるが、trueでなければ、
テストメソッドを中止しエラーを出力する。
この場合失敗した理由についての情報を追加するためにオプションの第二引数を使用可能。

プレーンなアサーションメソッドはエラー情報が良くないためできるだけ、
他のアサーションメソッドを使用したほうが良い。

下記の例は先程のテストメソッドを別のアサーションメソッドで書き換え、バージョン情報の他のコンポーネントのテストにも拡張したもの。
```
def test_can_parse_version_string v = Version.new("2.1.3")  assert_equal(2, v.major, "major”)
  assert_equal(l, v.minor, "minor”)
  assert_equal(3, v.patch, "patch”)end
```
assert_equalメソッドは2個の必須引数を取って、assertと同様にエラーが起きた時に表示されるメッセージをオプション引数として指定できる。
第一引数はエクスペクテーションする値。
第二引数は実際の値。

正しく引数を指定するとエラーメッセージで役立つ。
下記はassert_equalが生成するメッセージを見るために、わざとエラーを起こすテストメソッドを書いたもの。

```
def test_force_assertion_failure  v = Version.new("3.8.11")  assert_equal(4, v.major, "parsing major")endVersionTest#test_force_assertion_failureparsing major.
Expected: 4  Actual: 3
```

ここのアサーションメソッドは最後の引数として与えられたオプションの説明を組み込んだエラーメッセージを生成する。
これのおかげで、失敗した理由が理解しやすくなる。
MiniTestを使う前に利用できるアサーションメソッドをよく頭にいれておくと良い。

* 重複するコードを減らすためには。
  * 先頭が”test_”になっているメソッドしか呼ばないので、ヘルパーメソッドを書いて、テストメソッドから呼び出す。
  * setupという名前のメソッドを定義すると各メソッドの前に呼び出されることを利用する。

下記は、setupを使用した例。主にインスタンス変数に代入されるテストオブジェクトの作成に使用する。
```
def setup  cvl = Version.new("2.1.1") cv2 = Version・new("2.3.0")end
def test_version_compare 
  refute_equal(cvl, cv2)  assert_operator(cv1, :<, cv2) 
end
```


* まとめ
  * テストメソッドの名前には”test_”が必要
  * トラブルシューティングやメンテナンスのためにテストメソッドは短くする。
  * エラー事により良いメッセージを表示するために、最も適したアサーションを使う。

# 37 MiniTestスペックテストに慣れる。
MiniTestのスペックテストはユニットテストインターフェースに薄いラッパーをかけたものを通じて行い、
主にテスト作成の代替スタイルを提供する。
下記は、Versionクラスのために書いたユニットテストをスペックテストとして実装しなおしたもの。
```
require(‘minitest/autorun’)
describe(Version) do
  describe(“when parsing”) do
    before do
      @version = Version.new(“10.8.9”)
    end
    it(“creates three Integers”) do
      @version.major.must_equal(10)
      @version.minor.must_equal(8)
      @version.patch.must_wqual(9)
    end
  end

  descrie(“when comparing”) do
    before do
      @v1 = version.new(“2.1.1”)
      @v2 = version.new(“2.3.0”)
    end

    it(“orders corectiy”) do
      @v1.want_equal(@v2)
      @v1.must_be(:<, @v2)
    end
  end
end
```
ユニットテストで使ったアサーションションメソッドはスペックテストでも使えるが、スペックテストでは「エクスペクテーション」 と呼ばれるものを使う方が一般的。
エクスペクテーションは、Objectクラスに新しい名前 で注入されたおなじみのアサーションメソッドのことで、MiniTest:Expectationsモ ジュールでドキュメントされている。

* まとめ
  * テストクラスの作成にはdescribe、テストの定義にはitメソッドを使用する。
  * アサーションメソッドも使えるが、スペックテストでは一般にObjectクラスに注入されたエクスペくテーションメソッドを使う

# 38 モックオブジェクトで決定論をシュミレートしよう。

* まとめ
  * 外の世界の非決定性からテストを切り離したい時にはモックを使う
  * モックテストなどのメソッドを交換するテストは、本番でエラーを起こす未テストコードを残す危険がある。
  * テストメソッドを終える前にかならずMiniTest::Mock#verifyを呼び出す